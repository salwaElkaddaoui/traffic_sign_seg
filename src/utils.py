import json
import numpy as np
import cv2
import os
import random
from typing import List, Dict, Union
import matplotlib.pyplot as plt
import matplotlib
from collections import defaultdict

def polygon_to_mask(filepath: str, save_path: str, label_map: Dict, show: bool = True)->None:
    """
    Converts a JSON annotation file (from LabelMe) into a segmentation mask with integer-encoded classes.

    Args:
        filepath (str): Path to the JSON annotation file generated by LabelMe.
        save_path (str): Destination path to save the generated mask image.
        label_map (dict): A dictionary mapping class indices (as strings) to class names, e.g., {'0': 'dog', '1': 'cat'}.
        show (bool): If True, displays the generated mask.

    Returns:
        None.
    """
    with open(filepath, 'r') as file:
        data = json.load(file)

    height, width = data['imageHeight'], data['imageWidth']
    mask = np.zeros((height, width), dtype=np.uint8)

    # Invert the label map to map class name to index
    name_to_index = {v: int(k) for k, v in label_map.items()}

    for shape in data['shapes']:
        label_name = shape['label']
        class_index = name_to_index.get(label_name)

        if class_index is None:
            raise ValueError(f"Label '{label_name}' not found in label_map.")

        polygon_points = np.array([list(map(int, point)) for point in shape['points']])
        mask = cv2.fillPoly(mask, [polygon_points], color=class_index)

    if show:
        small_mask = cv2.resize(mask, (width // 10, height // 10), interpolation=cv2.INTER_NEAREST)
        cv2.imshow('mask', (small_mask * (255 // (len(label_map) or 1))).astype(np.uint8))
        cv2.waitKey(0)
        cv2.destroyAllWindows()

    cv2.imwrite(save_path, mask)


def generate_masks_from_folder(input_folder:str, output_folder:str, labelmap_path:str, show:bool)->None:
    """
    Generates segmentation masks from all LabelMe JSON annotation files in a folder.

    Args:
        input_folder (str): Path to the folder containing LabelMe JSON annotation files.
        output_folder (str): Path to the folder where generated mask images will be saved.
        labelmap_path (str): Path to a JSON file mapping class indices (as strings) to class names.
        show (bool): If True, displays each generated mask resized for visualization.

    Returns:
        None
    """
    with open(labelmap_path, 'r') as file:
        labelmap = json.load(file)

    # apply function to all images
    annotation_filenames = os.listdir(input_folder)
    for f in annotation_filenames:
        polygon_to_mask(filepath=os.path.join(input_folder, f), 
                        label_map=labelmap, 
                        save_path=os.path.join(output_folder, f.replace("json", "png")),
                        show=show)


def explore_image_mask_pairs(image_paths: List[str], mask_paths: List[str], labelmap: Dict[str, str],  num_samples: Union[int, None])->None:
    """
    Display image-mask pairs to inspect dataset consistency.
    Args:
        image_paths (list[str]): Paths to the dataset images.
        mask_paths (list[str]): Paths to the dataset masks.
        num_samples (int or None): Number of data samples to explore.
        labelmap (dict): Dictionary mapping class indices (as strings) to class names.
    Returns:
        None.
    """
    assert len(image_paths) == len(mask_paths), "Image and mask lists must be the same length."
    if num_samples is not None:
        indices = random.sample(range(len(image_paths)), num_samples)
    else:
        indices = list(range(len(image_paths)))
    cmap = matplotlib.colormaps.get_cmap('tab20')
    colors = [cmap(i)[:3] for i in range(len(labelmap))]
    colors_255 = [(np.array(color)*255).astype(np.uint8) for color in colors]
    for idx in indices:
        img = cv2.imread(image_paths[idx])
        mask = cv2.imread(mask_paths[idx],cv2.IMREAD_UNCHANGED)
        if img is not None:
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        assert img.shape[:2] == mask.shape[:2], f"Shape mismatch at index {i}: image shape = {img.shape[:2]}, mask shape = {mask.shape[:2]}"
        h, w = mask.shape
        color_mask = np.zeros((h, w, 3), dtype=np.uint8)
        for i in range(len(labelmap)):
            color_mask[mask == i] = colors_255[i]
        fig, ax = plt.subplots(1, 2, figsize=(12, 6))
        legend_elements = [matplotlib.patches.Patch(facecolor=colors[i], label=labelmap[str(i)]) for i in range(len(labelmap))]
        plt.legend(handles=legend_elements, loc='center left', bbox_to_anchor=(1.02, 0.5), borderaxespad=0., title="Classes")
        ax[0].set_title(f"Image: {os.path.basename(image_paths[idx])}")
        ax[0].imshow(img)
        ax[0].axis('off')
        print(image_paths[idx].split('/')[-1])
        ax[1].set_title(f"Mask: {os.path.basename(mask_paths[idx])}")
        ax[1].imshow(color_mask)
        ax[1].axis('off')
        plt.subplots_adjust(right=0.8) #to ensure that the legend has enough room, so that it is not truncated
        plt.tight_layout()
        plt.show()

def count_pixels(mask_paths: List[str], labelmap:Dict[str, str], show:bool=True) -> defaultdict:
    """
    Count then number of pixels belonging to each class.
    Args:
        mask_paths (list[str]): Paths to the dataset masks.
        labelmap (dict): Dictionary mapping class indices (as strings) to class names.
        show (bool): set to True to show the pixel count as bar plot.
    Returns:
        None.
    """
    count = defaultdict(int)
    for p in mask_paths:
        mask = cv2.imread(p, cv2.IMREAD_UNCHANGED)
        if mask is None:
            continue
        for class_idx_str in labelmap.keys():
            class_idx = int(class_idx_str)
            count[class_idx] += np.sum(mask==class_idx)
    if show:
        classes = list(labelmap.values())
        values = list(count.values())
        fig, ax = plt.subplots(1, 2, figsize=(12, 4))
        ax[0].bar(classes, values)
        ax[0].tick_params(axis='x', labelrotation=45)
        ax[0].set_xlabel('Classes')
        ax[0].set_ylabel('Number of pixels')
        ax[0].set_title("Class count including background class")
        ax[1].bar(classes[1:], values[1:])
        ax[1].tick_params(axis='x', labelrotation=45)
        ax[1].set_title("Class count (Zoom on foreground classes)")
        plt.tight_layout()
        plt.show()

    return count
